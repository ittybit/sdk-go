// This file was auto-generated by Fern from our API Definition.

package ittybit

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/fern-demo/ittybit-go-sdk/internal"
	time "time"
)

type MediaCreateRequest struct {
	// Title for the media
	Title *string `json:"title,omitempty" url:"-"`
	// Additional metadata for the media
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}

type MediaListRequest struct {
	// Number of media items to return per page.
	Limit *int `json:"-" url:"limit,omitempty"`
}

type ConfirmationResponse struct {
	Meta  *Meta                     `json:"meta,omitempty" url:"meta,omitempty"`
	Data  *ConfirmationResponseData `json:"data,omitempty" url:"data,omitempty"`
	Links *Links                    `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConfirmationResponse) GetMeta() *Meta {
	if c == nil {
		return nil
	}
	return c.Meta
}

func (c *ConfirmationResponse) GetData() *ConfirmationResponseData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *ConfirmationResponse) GetLinks() *Links {
	if c == nil {
		return nil
	}
	return c.Links
}

func (c *ConfirmationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfirmationResponseData struct {
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConfirmationResponseData) GetMessage() string {
	if c == nil {
		return ""
	}
	return c.Message
}

func (c *ConfirmationResponseData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationResponseData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Media struct {
	// Unique identifier for the media item.
	ID string `json:"id" url:"id"`
	// Object type, always 'media'.
	Object string `json:"object" url:"object"`
	// The primary kind of the media, derived from the original file.
	Kind MediaKind `json:"kind" url:"kind"`
	// Title of the media item.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Alternative text for the media item.
	Alt *string `json:"alt,omitempty" url:"alt,omitempty"`
	// Width of the primary source in pixels.
	Width *int `json:"width,omitempty" url:"width,omitempty"`
	// Height of the primary source in pixels.
	Height *int `json:"height,omitempty" url:"height,omitempty"`
	// Duration of the primary source in seconds.
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Array of source files associated with this media item.
	Files []*MediaSource `json:"files,omitempty" url:"files,omitempty"`
	// URLs for the media item.
	URLs *MediaURLs `json:"urls,omitempty" url:"urls,omitempty"`
	// URL of the poster image (video kinds only).
	Poster *string `json:"poster,omitempty" url:"poster,omitempty"`
	// Base64 encoded placeholder image (video/image only).
	Placeholder *string `json:"placeholder,omitempty" url:"placeholder,omitempty"`
	// Dominant background color hex code (video/image only).
	Background *string `json:"background,omitempty" url:"background,omitempty"`
	// User-defined key-value metadata for the media item.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Timestamp when the media record was created.
	Created time.Time `json:"created" url:"created"`
	// Timestamp when the media item was last updated.
	Updated time.Time `json:"updated" url:"updated"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Media) GetID() string {
	if m == nil {
		return ""
	}
	return m.ID
}

func (m *Media) GetObject() string {
	if m == nil {
		return ""
	}
	return m.Object
}

func (m *Media) GetKind() MediaKind {
	if m == nil {
		return ""
	}
	return m.Kind
}

func (m *Media) GetTitle() *string {
	if m == nil {
		return nil
	}
	return m.Title
}

func (m *Media) GetAlt() *string {
	if m == nil {
		return nil
	}
	return m.Alt
}

func (m *Media) GetWidth() *int {
	if m == nil {
		return nil
	}
	return m.Width
}

func (m *Media) GetHeight() *int {
	if m == nil {
		return nil
	}
	return m.Height
}

func (m *Media) GetDuration() *float64 {
	if m == nil {
		return nil
	}
	return m.Duration
}

func (m *Media) GetFiles() []*MediaSource {
	if m == nil {
		return nil
	}
	return m.Files
}

func (m *Media) GetURLs() *MediaURLs {
	if m == nil {
		return nil
	}
	return m.URLs
}

func (m *Media) GetPoster() *string {
	if m == nil {
		return nil
	}
	return m.Poster
}

func (m *Media) GetPlaceholder() *string {
	if m == nil {
		return nil
	}
	return m.Placeholder
}

func (m *Media) GetBackground() *string {
	if m == nil {
		return nil
	}
	return m.Background
}

func (m *Media) GetMetadata() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *Media) GetCreated() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Created
}

func (m *Media) GetUpdated() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Updated
}

func (m *Media) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Media) UnmarshalJSON(data []byte) error {
	type embed Media
	var unmarshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Media(unmarshaler.embed)
	m.Created = unmarshaler.Created.Time()
	m.Updated = unmarshaler.Updated.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Media) MarshalJSON() ([]byte, error) {
	type embed Media
	var marshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed:   embed(*m),
		Created: internal.NewDateTime(m.Created),
		Updated: internal.NewDateTime(m.Updated),
	}
	return json.Marshal(marshaler)
}

func (m *Media) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The primary kind of the media, derived from the original file.
type MediaKind string

const (
	MediaKindVideo MediaKind = "video"
	MediaKindImage MediaKind = "image"
	MediaKindAudio MediaKind = "audio"
)

func NewMediaKindFromString(s string) (MediaKind, error) {
	switch s {
	case "video":
		return MediaKindVideo, nil
	case "image":
		return MediaKindImage, nil
	case "audio":
		return MediaKindAudio, nil
	}
	var t MediaKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MediaKind) Ptr() *MediaKind {
	return &m
}

type MediaListResponse struct {
	Meta  *MetaList  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  []*Media   `json:"data,omitempty" url:"data,omitempty"`
	Links *LinksList `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MediaListResponse) GetMeta() *MetaList {
	if m == nil {
		return nil
	}
	return m.Meta
}

func (m *MediaListResponse) GetData() []*Media {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MediaListResponse) GetLinks() *LinksList {
	if m == nil {
		return nil
	}
	return m.Links
}

func (m *MediaListResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MediaListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MediaListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MediaListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaListResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MediaResponse struct {
	Meta  *Meta  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  *Media `json:"data,omitempty" url:"data,omitempty"`
	Links *Links `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MediaResponse) GetMeta() *Meta {
	if m == nil {
		return nil
	}
	return m.Meta
}

func (m *MediaResponse) GetData() *Media {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MediaResponse) GetLinks() *Links {
	if m == nil {
		return nil
	}
	return m.Links
}

func (m *MediaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MediaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MediaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MediaResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MediaSource struct {
	// Unique identifier for the file.
	ID string `json:"id" url:"id"`
	// Object type
	Object MediaSourceObject `json:"object" url:"object"`
	// The general type of media.
	Kind MediaSourceKind `json:"kind" url:"kind"`
	// MIME type.
	Type string `json:"type" url:"type"`
	// Codec of the file.
	Codec *string `json:"codec,omitempty" url:"codec,omitempty"`
	// Container of the file.
	Container *string `json:"container,omitempty" url:"container,omitempty"`
	// Width in pixels (for image/video).
	Width *int `json:"width,omitempty" url:"width,omitempty"`
	// Height in pixels (for image/video).
	Height *int `json:"height,omitempty" url:"height,omitempty"`
	// Orientation of the file.
	Orientation *string `json:"orientation,omitempty" url:"orientation,omitempty"`
	// Rotation value for image files with embedded EXIF data.
	Rotation *float64 `json:"rotation,omitempty" url:"rotation,omitempty"`
	// Indicates if the file has alpha channel.
	Transparency *bool `json:"transparency,omitempty" url:"transparency,omitempty"`
	// Number of frames in the file.
	Frames *int `json:"frames,omitempty" url:"frames,omitempty"`
	// Duration in seconds (for audio/video).
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Frames per second (for video).
	Fps *float64 `json:"fps,omitempty" url:"fps,omitempty"`
	// File size in bytes.
	Filesize int `json:"filesize" url:"filesize"`
	// Bitrate for audio/video files.
	Bitrate *int `json:"bitrate,omitempty" url:"bitrate,omitempty"`
	// Optional reference value. If set, the file URL will be included in the parent media `urls` object.
	Ref *string `json:"ref,omitempty" url:"ref,omitempty"`
	// The folder path where the file is stored.
	Folder *string `json:"folder,omitempty" url:"folder,omitempty"`
	// The name of the file.
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// Publicly accessible URL for the file.
	URL string `json:"url" url:"url"`
	// User-defined key-value metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Indicates this is the original file rather than a variant.
	Original *bool `json:"original,omitempty" url:"original,omitempty"`
	// Timestamp when the file record was created.
	Created time.Time `json:"created" url:"created"`
	// Timestamp when the file record was last updated.
	Updated time.Time `json:"updated" url:"updated"`
	// Processing status of the file.
	Status MediaSourceStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MediaSource) GetID() string {
	if m == nil {
		return ""
	}
	return m.ID
}

func (m *MediaSource) GetObject() MediaSourceObject {
	if m == nil {
		return ""
	}
	return m.Object
}

func (m *MediaSource) GetKind() MediaSourceKind {
	if m == nil {
		return ""
	}
	return m.Kind
}

func (m *MediaSource) GetType() string {
	if m == nil {
		return ""
	}
	return m.Type
}

func (m *MediaSource) GetCodec() *string {
	if m == nil {
		return nil
	}
	return m.Codec
}

func (m *MediaSource) GetContainer() *string {
	if m == nil {
		return nil
	}
	return m.Container
}

func (m *MediaSource) GetWidth() *int {
	if m == nil {
		return nil
	}
	return m.Width
}

func (m *MediaSource) GetHeight() *int {
	if m == nil {
		return nil
	}
	return m.Height
}

func (m *MediaSource) GetOrientation() *string {
	if m == nil {
		return nil
	}
	return m.Orientation
}

func (m *MediaSource) GetRotation() *float64 {
	if m == nil {
		return nil
	}
	return m.Rotation
}

func (m *MediaSource) GetTransparency() *bool {
	if m == nil {
		return nil
	}
	return m.Transparency
}

func (m *MediaSource) GetFrames() *int {
	if m == nil {
		return nil
	}
	return m.Frames
}

func (m *MediaSource) GetDuration() *float64 {
	if m == nil {
		return nil
	}
	return m.Duration
}

func (m *MediaSource) GetFps() *float64 {
	if m == nil {
		return nil
	}
	return m.Fps
}

func (m *MediaSource) GetFilesize() int {
	if m == nil {
		return 0
	}
	return m.Filesize
}

func (m *MediaSource) GetBitrate() *int {
	if m == nil {
		return nil
	}
	return m.Bitrate
}

func (m *MediaSource) GetRef() *string {
	if m == nil {
		return nil
	}
	return m.Ref
}

func (m *MediaSource) GetFolder() *string {
	if m == nil {
		return nil
	}
	return m.Folder
}

func (m *MediaSource) GetFilename() *string {
	if m == nil {
		return nil
	}
	return m.Filename
}

func (m *MediaSource) GetURL() string {
	if m == nil {
		return ""
	}
	return m.URL
}

func (m *MediaSource) GetMetadata() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *MediaSource) GetOriginal() *bool {
	if m == nil {
		return nil
	}
	return m.Original
}

func (m *MediaSource) GetCreated() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Created
}

func (m *MediaSource) GetUpdated() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.Updated
}

func (m *MediaSource) GetStatus() MediaSourceStatus {
	if m == nil {
		return ""
	}
	return m.Status
}

func (m *MediaSource) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MediaSource) UnmarshalJSON(data []byte) error {
	type embed MediaSource
	var unmarshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MediaSource(unmarshaler.embed)
	m.Created = unmarshaler.Created.Time()
	m.Updated = unmarshaler.Updated.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaSource) MarshalJSON() ([]byte, error) {
	type embed MediaSource
	var marshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed:   embed(*m),
		Created: internal.NewDateTime(m.Created),
		Updated: internal.NewDateTime(m.Updated),
	}
	return json.Marshal(marshaler)
}

func (m *MediaSource) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The general type of media.
type MediaSourceKind string

const (
	MediaSourceKindVideo MediaSourceKind = "video"
	MediaSourceKindImage MediaSourceKind = "image"
	MediaSourceKindAudio MediaSourceKind = "audio"
)

func NewMediaSourceKindFromString(s string) (MediaSourceKind, error) {
	switch s {
	case "video":
		return MediaSourceKindVideo, nil
	case "image":
		return MediaSourceKindImage, nil
	case "audio":
		return MediaSourceKindAudio, nil
	}
	var t MediaSourceKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MediaSourceKind) Ptr() *MediaSourceKind {
	return &m
}

// Object type
type MediaSourceObject string

const (
	MediaSourceObjectSource       MediaSourceObject = "source"
	MediaSourceObjectTrack        MediaSourceObject = "track"
	MediaSourceObjectIntelligence MediaSourceObject = "intelligence"
)

func NewMediaSourceObjectFromString(s string) (MediaSourceObject, error) {
	switch s {
	case "source":
		return MediaSourceObjectSource, nil
	case "track":
		return MediaSourceObjectTrack, nil
	case "intelligence":
		return MediaSourceObjectIntelligence, nil
	}
	var t MediaSourceObject
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MediaSourceObject) Ptr() *MediaSourceObject {
	return &m
}

// Processing status of the file.
type MediaSourceStatus string

const (
	MediaSourceStatusWaiting    MediaSourceStatus = "waiting"
	MediaSourceStatusProcessing MediaSourceStatus = "processing"
	MediaSourceStatusReady      MediaSourceStatus = "ready"
	MediaSourceStatusFailed     MediaSourceStatus = "failed"
)

func NewMediaSourceStatusFromString(s string) (MediaSourceStatus, error) {
	switch s {
	case "waiting":
		return MediaSourceStatusWaiting, nil
	case "processing":
		return MediaSourceStatusProcessing, nil
	case "ready":
		return MediaSourceStatusReady, nil
	case "failed":
		return MediaSourceStatusFailed, nil
	}
	var t MediaSourceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MediaSourceStatus) Ptr() *MediaSourceStatus {
	return &m
}

// URLs for the media item.
type MediaURLs struct {
	// URL of the original source file.
	Original *string `json:"original,omitempty" url:"original,omitempty"`
	// Example URL for a file with the ref value "example_ref". Any key with a-z, 0-9, _, or - is possible, but keys must start with a letter.
	ExampleRef *string `json:"example_ref,omitempty" url:"example_ref,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MediaURLs) GetOriginal() *string {
	if m == nil {
		return nil
	}
	return m.Original
}

func (m *MediaURLs) GetExampleRef() *string {
	if m == nil {
		return nil
	}
	return m.ExampleRef
}

func (m *MediaURLs) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MediaURLs) UnmarshalJSON(data []byte) error {
	type unmarshaler MediaURLs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MediaURLs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MediaURLs) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MediaUpdateRequest struct {
	// New title for the media item.
	Title *string `json:"title,omitempty" url:"-"`
	// New metadata object for the media item. This will replace the existing metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}
