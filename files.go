// This file was auto-generated by Fern from our API Definition.

package ittybit

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/fern-demo/ittybit-go-sdk/internal"
	time "time"
)

type FilesCreateRequest struct {
	// The publicly accessible URL of the file to ingest.
	URL string `json:"url" url:"-"`
	// Optional desired filename. If not provided, it may be derived from the URL.
	Filename *string `json:"filename,omitempty" url:"-"`
	// Folder path (optional)
	Folder *string `json:"folder,omitempty" url:"-"`
	// Optional existing media ID to associate the file with.
	MediaID *string `json:"media_id,omitempty" url:"-"`
	// Optional label for the file.
	Label *string `json:"label,omitempty" url:"-"`
	// Optional user-defined key-value metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
	// Whether to process the ingestion asynchronously.
	Async *bool `json:"async,omitempty" url:"-"`
}

type FilesListRequest struct {
	// Items per page
	Limit *int `json:"-" url:"limit,omitempty"`
}

type File struct {
	// Unique identifier for the file.
	ID string `json:"id" url:"id"`
	// Identifier for the parent media object.
	MediaID string `json:"media_id" url:"media_id"`
	// Object type
	Object FileObject `json:"object" url:"object"`
	// The general type of media.
	Kind FileKind `json:"kind" url:"kind"`
	// MIME type.
	Type string `json:"type" url:"type"`
	// Codec of the file.
	Codec *string `json:"codec,omitempty" url:"codec,omitempty"`
	// Container of the file.
	Container *string `json:"container,omitempty" url:"container,omitempty"`
	// Width in pixels (for image/video).
	Width *int `json:"width,omitempty" url:"width,omitempty"`
	// Height in pixels (for image/video).
	Height *int `json:"height,omitempty" url:"height,omitempty"`
	// Orientation of the file.
	Orientation *string `json:"orientation,omitempty" url:"orientation,omitempty"`
	// Rotation value for image files with embedded EXIF data.
	Rotation *float64 `json:"rotation,omitempty" url:"rotation,omitempty"`
	// Indicates if the file has alpha channel.
	Transparency *bool `json:"transparency,omitempty" url:"transparency,omitempty"`
	// Indicates if the file is animated (image only).
	Animated *bool `json:"animated,omitempty" url:"animated,omitempty"`
	// Number of frames in the file.
	Frames *int `json:"frames,omitempty" url:"frames,omitempty"`
	// Duration in seconds (for audio/video).
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Frames per second (for video).
	Fps *float64 `json:"fps,omitempty" url:"fps,omitempty"`
	// File size in bytes.
	Filesize int `json:"filesize" url:"filesize"`
	// Bitrate for audio/video files.
	Bitrate *int `json:"bitrate,omitempty" url:"bitrate,omitempty"`
	// Language code (e.g., en, es, fr).
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// Label to be used by players (tracks only).
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// Optional reference value. If set, the file URL will be included in the parent media `urls` object.
	Ref *string `json:"ref,omitempty" url:"ref,omitempty"`
	// The folder path where the file is stored.
	Folder *string `json:"folder,omitempty" url:"folder,omitempty"`
	// The name of the file.
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// Publicly accessible URL for the file.
	URL string `json:"url" url:"url"`
	// Base64 encoded placeholder image for the file.
	Placeholder *string `json:"placeholder,omitempty" url:"placeholder,omitempty"`
	// Dominant background color hex code.
	Background *string `json:"background,omitempty" url:"background,omitempty"`
	// User-defined key-value metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Indicates this is the original file rather than a variant.
	Original *bool `json:"original,omitempty" url:"original,omitempty"`
	// ID of the entity (e.g., task, automation, or upload request) that created this file.
	CreatedBy *string `json:"created_by,omitempty" url:"created_by,omitempty"`
	// Timestamp when the file record was created.
	Created time.Time `json:"created" url:"created"`
	// Timestamp when the file record was last updated.
	Updated time.Time `json:"updated" url:"updated"`
	// Processing status of the file.
	Status FileStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *File) GetID() string {
	if f == nil {
		return ""
	}
	return f.ID
}

func (f *File) GetMediaID() string {
	if f == nil {
		return ""
	}
	return f.MediaID
}

func (f *File) GetObject() FileObject {
	if f == nil {
		return ""
	}
	return f.Object
}

func (f *File) GetKind() FileKind {
	if f == nil {
		return ""
	}
	return f.Kind
}

func (f *File) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *File) GetCodec() *string {
	if f == nil {
		return nil
	}
	return f.Codec
}

func (f *File) GetContainer() *string {
	if f == nil {
		return nil
	}
	return f.Container
}

func (f *File) GetWidth() *int {
	if f == nil {
		return nil
	}
	return f.Width
}

func (f *File) GetHeight() *int {
	if f == nil {
		return nil
	}
	return f.Height
}

func (f *File) GetOrientation() *string {
	if f == nil {
		return nil
	}
	return f.Orientation
}

func (f *File) GetRotation() *float64 {
	if f == nil {
		return nil
	}
	return f.Rotation
}

func (f *File) GetTransparency() *bool {
	if f == nil {
		return nil
	}
	return f.Transparency
}

func (f *File) GetAnimated() *bool {
	if f == nil {
		return nil
	}
	return f.Animated
}

func (f *File) GetFrames() *int {
	if f == nil {
		return nil
	}
	return f.Frames
}

func (f *File) GetDuration() *float64 {
	if f == nil {
		return nil
	}
	return f.Duration
}

func (f *File) GetFps() *float64 {
	if f == nil {
		return nil
	}
	return f.Fps
}

func (f *File) GetFilesize() int {
	if f == nil {
		return 0
	}
	return f.Filesize
}

func (f *File) GetBitrate() *int {
	if f == nil {
		return nil
	}
	return f.Bitrate
}

func (f *File) GetLanguage() *string {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *File) GetLabel() *string {
	if f == nil {
		return nil
	}
	return f.Label
}

func (f *File) GetRef() *string {
	if f == nil {
		return nil
	}
	return f.Ref
}

func (f *File) GetFolder() *string {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *File) GetFilename() *string {
	if f == nil {
		return nil
	}
	return f.Filename
}

func (f *File) GetURL() string {
	if f == nil {
		return ""
	}
	return f.URL
}

func (f *File) GetPlaceholder() *string {
	if f == nil {
		return nil
	}
	return f.Placeholder
}

func (f *File) GetBackground() *string {
	if f == nil {
		return nil
	}
	return f.Background
}

func (f *File) GetMetadata() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *File) GetOriginal() *bool {
	if f == nil {
		return nil
	}
	return f.Original
}

func (f *File) GetCreatedBy() *string {
	if f == nil {
		return nil
	}
	return f.CreatedBy
}

func (f *File) GetCreated() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.Created
}

func (f *File) GetUpdated() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.Updated
}

func (f *File) GetStatus() FileStatus {
	if f == nil {
		return ""
	}
	return f.Status
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.Created = unmarshaler.Created.Time()
	f.Updated = unmarshaler.Updated.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed:   embed(*f),
		Created: internal.NewDateTime(f.Created),
		Updated: internal.NewDateTime(f.Updated),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The general type of media.
type FileKind string

const (
	FileKindVideo FileKind = "video"
	FileKindImage FileKind = "image"
	FileKindAudio FileKind = "audio"
)

func NewFileKindFromString(s string) (FileKind, error) {
	switch s {
	case "video":
		return FileKindVideo, nil
	case "image":
		return FileKindImage, nil
	case "audio":
		return FileKindAudio, nil
	}
	var t FileKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileKind) Ptr() *FileKind {
	return &f
}

type FileListResponse struct {
	Meta  *MetaList  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  []*File    `json:"data,omitempty" url:"data,omitempty"`
	Links *LinksList `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileListResponse) GetMeta() *MetaList {
	if f == nil {
		return nil
	}
	return f.Meta
}

func (f *FileListResponse) GetData() []*File {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FileListResponse) GetLinks() *LinksList {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FileListResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileListResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object type
type FileObject string

const (
	FileObjectSource       FileObject = "source"
	FileObjectTrack        FileObject = "track"
	FileObjectIntelligence FileObject = "intelligence"
)

func NewFileObjectFromString(s string) (FileObject, error) {
	switch s {
	case "source":
		return FileObjectSource, nil
	case "track":
		return FileObjectTrack, nil
	case "intelligence":
		return FileObjectIntelligence, nil
	}
	var t FileObject
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileObject) Ptr() *FileObject {
	return &f
}

type FileResponse struct {
	Meta  *Meta  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  *File  `json:"data,omitempty" url:"data,omitempty"`
	Links *Links `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileResponse) GetMeta() *Meta {
	if f == nil {
		return nil
	}
	return f.Meta
}

func (f *FileResponse) GetData() *File {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FileResponse) GetLinks() *Links {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FileResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Processing status of the file.
type FileStatus string

const (
	FileStatusWaiting    FileStatus = "waiting"
	FileStatusProcessing FileStatus = "processing"
	FileStatusReady      FileStatus = "ready"
	FileStatusFailed     FileStatus = "failed"
)

func NewFileStatusFromString(s string) (FileStatus, error) {
	switch s {
	case "waiting":
		return FileStatusWaiting, nil
	case "processing":
		return FileStatusProcessing, nil
	case "ready":
		return FileStatusReady, nil
	case "failed":
		return FileStatusFailed, nil
	}
	var t FileStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileStatus) Ptr() *FileStatus {
	return &f
}

type FilesDeleteResponse struct {
	// Contains a confirmation message
	Data  *FilesDeleteResponseData `json:"data,omitempty" url:"data,omitempty"`
	Meta  *Meta                    `json:"meta,omitempty" url:"meta,omitempty"`
	Links *Links                   `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilesDeleteResponse) GetData() *FilesDeleteResponseData {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FilesDeleteResponse) GetMeta() *Meta {
	if f == nil {
		return nil
	}
	return f.Meta
}

func (f *FilesDeleteResponse) GetLinks() *Links {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FilesDeleteResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilesDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FilesDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilesDeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilesDeleteResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains a confirmation message
type FilesDeleteResponseData struct {
	// Confirmation message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilesDeleteResponseData) GetMessage() *string {
	if f == nil {
		return nil
	}
	return f.Message
}

func (f *FilesDeleteResponseData) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilesDeleteResponseData) UnmarshalJSON(data []byte) error {
	type unmarshaler FilesDeleteResponseData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilesDeleteResponseData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilesDeleteResponseData) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FilesUpdateRequest struct {
	// An object containing key-value pairs to set or update. Set a key to null to remove it.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
	// New filename for the file.
	Filename *string `json:"filename,omitempty" url:"-"`
	// New folder path for the file.
	Folder *string `json:"folder,omitempty" url:"-"`
}
