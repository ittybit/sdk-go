// This file was auto-generated by Fern from our API Definition.

package ittybit

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/ittybit/sdk-go/internal"
	time "time"
)

type FilesCreateRequest struct {
	URL      string                 `json:"url" url:"-"`
	MediaID  *string                `json:"media_id,omitempty" url:"-"`
	Folder   *string                `json:"folder,omitempty" url:"-"`
	Filename *string                `json:"filename,omitempty" url:"-"`
	Ref      *string                `json:"ref,omitempty" url:"-"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}

type FilesListRequest struct {
	Page  *int `json:"-" url:"page,omitempty"`
	Limit *int `json:"-" url:"limit,omitempty"`
}

type File struct {
	ID           string                 `json:"id" url:"id"`
	MediaID      string                 `json:"media_id" url:"media_id"`
	Object       FileObject             `json:"object" url:"object"`
	Kind         FileKind               `json:"kind" url:"kind"`
	Type         string                 `json:"type" url:"type"`
	Codec        *string                `json:"codec,omitempty" url:"codec,omitempty"`
	Container    *string                `json:"container,omitempty" url:"container,omitempty"`
	Width        *int                   `json:"width,omitempty" url:"width,omitempty"`
	Height       *int                   `json:"height,omitempty" url:"height,omitempty"`
	Orientation  *string                `json:"orientation,omitempty" url:"orientation,omitempty"`
	Rotation     *float64               `json:"rotation,omitempty" url:"rotation,omitempty"`
	Transparency *bool                  `json:"transparency,omitempty" url:"transparency,omitempty"`
	Animated     *bool                  `json:"animated,omitempty" url:"animated,omitempty"`
	Frames       *int                   `json:"frames,omitempty" url:"frames,omitempty"`
	Duration     *float64               `json:"duration,omitempty" url:"duration,omitempty"`
	Fps          *float64               `json:"fps,omitempty" url:"fps,omitempty"`
	Filesize     int                    `json:"filesize" url:"filesize"`
	Bitrate      *int                   `json:"bitrate,omitempty" url:"bitrate,omitempty"`
	Language     *string                `json:"language,omitempty" url:"language,omitempty"`
	Label        *string                `json:"label,omitempty" url:"label,omitempty"`
	Ref          *string                `json:"ref,omitempty" url:"ref,omitempty"`
	Folder       *string                `json:"folder,omitempty" url:"folder,omitempty"`
	Filename     *string                `json:"filename,omitempty" url:"filename,omitempty"`
	URL          string                 `json:"url" url:"url"`
	Placeholder  *string                `json:"placeholder,omitempty" url:"placeholder,omitempty"`
	Background   *string                `json:"background,omitempty" url:"background,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Original     *bool                  `json:"original,omitempty" url:"original,omitempty"`
	CreatedBy    *string                `json:"created_by,omitempty" url:"created_by,omitempty"`
	Created      time.Time              `json:"created" url:"created"`
	Updated      time.Time              `json:"updated" url:"updated"`
	Status       FileStatus             `json:"status" url:"status"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *File) GetID() string {
	if f == nil {
		return ""
	}
	return f.ID
}

func (f *File) GetMediaID() string {
	if f == nil {
		return ""
	}
	return f.MediaID
}

func (f *File) GetObject() FileObject {
	if f == nil {
		return ""
	}
	return f.Object
}

func (f *File) GetKind() FileKind {
	if f == nil {
		return ""
	}
	return f.Kind
}

func (f *File) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *File) GetCodec() *string {
	if f == nil {
		return nil
	}
	return f.Codec
}

func (f *File) GetContainer() *string {
	if f == nil {
		return nil
	}
	return f.Container
}

func (f *File) GetWidth() *int {
	if f == nil {
		return nil
	}
	return f.Width
}

func (f *File) GetHeight() *int {
	if f == nil {
		return nil
	}
	return f.Height
}

func (f *File) GetOrientation() *string {
	if f == nil {
		return nil
	}
	return f.Orientation
}

func (f *File) GetRotation() *float64 {
	if f == nil {
		return nil
	}
	return f.Rotation
}

func (f *File) GetTransparency() *bool {
	if f == nil {
		return nil
	}
	return f.Transparency
}

func (f *File) GetAnimated() *bool {
	if f == nil {
		return nil
	}
	return f.Animated
}

func (f *File) GetFrames() *int {
	if f == nil {
		return nil
	}
	return f.Frames
}

func (f *File) GetDuration() *float64 {
	if f == nil {
		return nil
	}
	return f.Duration
}

func (f *File) GetFps() *float64 {
	if f == nil {
		return nil
	}
	return f.Fps
}

func (f *File) GetFilesize() int {
	if f == nil {
		return 0
	}
	return f.Filesize
}

func (f *File) GetBitrate() *int {
	if f == nil {
		return nil
	}
	return f.Bitrate
}

func (f *File) GetLanguage() *string {
	if f == nil {
		return nil
	}
	return f.Language
}

func (f *File) GetLabel() *string {
	if f == nil {
		return nil
	}
	return f.Label
}

func (f *File) GetRef() *string {
	if f == nil {
		return nil
	}
	return f.Ref
}

func (f *File) GetFolder() *string {
	if f == nil {
		return nil
	}
	return f.Folder
}

func (f *File) GetFilename() *string {
	if f == nil {
		return nil
	}
	return f.Filename
}

func (f *File) GetURL() string {
	if f == nil {
		return ""
	}
	return f.URL
}

func (f *File) GetPlaceholder() *string {
	if f == nil {
		return nil
	}
	return f.Placeholder
}

func (f *File) GetBackground() *string {
	if f == nil {
		return nil
	}
	return f.Background
}

func (f *File) GetMetadata() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *File) GetOriginal() *bool {
	if f == nil {
		return nil
	}
	return f.Original
}

func (f *File) GetCreatedBy() *string {
	if f == nil {
		return nil
	}
	return f.CreatedBy
}

func (f *File) GetCreated() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.Created
}

func (f *File) GetUpdated() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.Updated
}

func (f *File) GetStatus() FileStatus {
	if f == nil {
		return ""
	}
	return f.Status
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.Created = unmarshaler.Created.Time()
	f.Updated = unmarshaler.Updated.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		Created *internal.DateTime `json:"created"`
		Updated *internal.DateTime `json:"updated"`
	}{
		embed:   embed(*f),
		Created: internal.NewDateTime(f.Created),
		Updated: internal.NewDateTime(f.Updated),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileKind string

const (
	FileKindVideo FileKind = "video"
	FileKindImage FileKind = "image"
	FileKindAudio FileKind = "audio"
)

func NewFileKindFromString(s string) (FileKind, error) {
	switch s {
	case "video":
		return FileKindVideo, nil
	case "image":
		return FileKindImage, nil
	case "audio":
		return FileKindAudio, nil
	}
	var t FileKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileKind) Ptr() *FileKind {
	return &f
}

type FileListResponse struct {
	Meta  *MetaList  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  []*File    `json:"data,omitempty" url:"data,omitempty"`
	Error *Error     `json:"error,omitempty" url:"error,omitempty"`
	Links *LinksList `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileListResponse) GetMeta() *MetaList {
	if f == nil {
		return nil
	}
	return f.Meta
}

func (f *FileListResponse) GetData() []*File {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FileListResponse) GetError() *Error {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FileListResponse) GetLinks() *LinksList {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FileListResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileListResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileObject string

const (
	FileObjectSource       FileObject = "source"
	FileObjectTrack        FileObject = "track"
	FileObjectIntelligence FileObject = "intelligence"
)

func NewFileObjectFromString(s string) (FileObject, error) {
	switch s {
	case "source":
		return FileObjectSource, nil
	case "track":
		return FileObjectTrack, nil
	case "intelligence":
		return FileObjectIntelligence, nil
	}
	var t FileObject
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileObject) Ptr() *FileObject {
	return &f
}

type FileResponse struct {
	Meta  *Meta  `json:"meta,omitempty" url:"meta,omitempty"`
	Data  *File  `json:"data,omitempty" url:"data,omitempty"`
	Error *Error `json:"error,omitempty" url:"error,omitempty"`
	Links *Links `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FileResponse) GetMeta() *Meta {
	if f == nil {
		return nil
	}
	return f.Meta
}

func (f *FileResponse) GetData() *File {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FileResponse) GetError() *Error {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FileResponse) GetLinks() *Links {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FileResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FileResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FileStatus string

const (
	FileStatusWaiting    FileStatus = "waiting"
	FileStatusProcessing FileStatus = "processing"
	FileStatusReady      FileStatus = "ready"
	FileStatusFailed     FileStatus = "failed"
)

func NewFileStatusFromString(s string) (FileStatus, error) {
	switch s {
	case "waiting":
		return FileStatusWaiting, nil
	case "processing":
		return FileStatusProcessing, nil
	case "ready":
		return FileStatusReady, nil
	case "failed":
		return FileStatusFailed, nil
	}
	var t FileStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FileStatus) Ptr() *FileStatus {
	return &f
}

type FilesUpdateRequest struct {
	Folder   *string                `json:"folder,omitempty" url:"-"`
	Filename *string                `json:"filename,omitempty" url:"-"`
	Ref      *string                `json:"ref,omitempty" url:"-"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}
