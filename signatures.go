// This file was auto-generated by Fern from our API Definition.

package ittybit

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/ittybit/sdk-go/internal"
)

type SignaturesCreateRequest struct {
	// The name of the file to generate a signature for. Special characters will be sanitised.
	Filename string `json:"filename" url:"-"`
	// Optional folder path where the file resides. Special characters will be sanitised.
	Folder *string `json:"folder,omitempty" url:"-"`
	// Optional expiry time for the signature in seconds since epoch. Defaults to 60 minutes from now. Must be a positive integer and in the future.
	Expiry *int64 `json:"expiry,omitempty" url:"-"`
	// Optional HTTP method allowed for the signed URL. Defaults to 'get'.
	Method *SignaturesCreateRequestMethod `json:"method,omitempty" url:"-"`
}

type Signature struct {
	// Domain of the signed URL
	Domain string `json:"domain" url:"domain"`
	// Filename of the signed file
	Filename string `json:"filename" url:"filename"`
	// Folder of the signed file
	Folder *string `json:"folder,omitempty" url:"folder,omitempty"`
	// Expiry timestamp of the signed URL
	Expiry int `json:"expiry" url:"expiry"`
	// HTTP method for the signed URL
	Method string `json:"method" url:"method"`
	// Generated signature for the signed URL
	Signature string `json:"signature" url:"signature"`
	// Generated signed URL
	URL string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Signature) GetDomain() string {
	if s == nil {
		return ""
	}
	return s.Domain
}

func (s *Signature) GetFilename() string {
	if s == nil {
		return ""
	}
	return s.Filename
}

func (s *Signature) GetFolder() *string {
	if s == nil {
		return nil
	}
	return s.Folder
}

func (s *Signature) GetExpiry() int {
	if s == nil {
		return 0
	}
	return s.Expiry
}

func (s *Signature) GetMethod() string {
	if s == nil {
		return ""
	}
	return s.Method
}

func (s *Signature) GetSignature() string {
	if s == nil {
		return ""
	}
	return s.Signature
}

func (s *Signature) GetURL() string {
	if s == nil {
		return ""
	}
	return s.URL
}

func (s *Signature) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Signature) UnmarshalJSON(data []byte) error {
	type unmarshaler Signature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Signature(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Signature) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignatureResponse struct {
	Meta  *Meta      `json:"meta,omitempty" url:"meta,omitempty"`
	Data  *Signature `json:"data,omitempty" url:"data,omitempty"`
	Links *Links     `json:"links,omitempty" url:"links,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureResponse) GetMeta() *Meta {
	if s == nil {
		return nil
	}
	return s.Meta
}

func (s *SignatureResponse) GetData() *Signature {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SignatureResponse) GetLinks() *Links {
	if s == nil {
		return nil
	}
	return s.Links
}

func (s *SignatureResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Optional HTTP method allowed for the signed URL. Defaults to 'get'.
type SignaturesCreateRequestMethod string

const (
	SignaturesCreateRequestMethodGet    SignaturesCreateRequestMethod = "get"
	SignaturesCreateRequestMethodPut    SignaturesCreateRequestMethod = "put"
	SignaturesCreateRequestMethodPost   SignaturesCreateRequestMethod = "post"
	SignaturesCreateRequestMethodDelete SignaturesCreateRequestMethod = "delete"
)

func NewSignaturesCreateRequestMethodFromString(s string) (SignaturesCreateRequestMethod, error) {
	switch s {
	case "get":
		return SignaturesCreateRequestMethodGet, nil
	case "put":
		return SignaturesCreateRequestMethodPut, nil
	case "post":
		return SignaturesCreateRequestMethodPost, nil
	case "delete":
		return SignaturesCreateRequestMethodDelete, nil
	}
	var t SignaturesCreateRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SignaturesCreateRequestMethod) Ptr() *SignaturesCreateRequestMethod {
	return &s
}
